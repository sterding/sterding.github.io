---
layout: post
title: smart binindex system of storing genomic data
date: '2013-05-21T13:05:00.001-04:00'
author: Xianjun Dong
tags:
- binindex
- data structure
modified_time: '2013-05-21T13:05:30.971-04:00'
thumbnail: http://3.bp.blogspot.com/-6k8AcqelBOM/UZt7y1RAEBI/AAAAAAAAAc4/778Qzl0EVnM/s72-c/F7.medium.gif
blogger_id: tag:blogger.com,1999:blog-12445049.post-4620418820682539361
blogger_orig_url: http://onetipperday.blogspot.com/2013/05/smart-binindex-system-of-storing.html
---

<div class="separator" style="clear: both; text-align: left;"><a href="https://github.com/nimezhu/bam2x/wiki/%5BCN%5DBAM2X-TUTORIAL">XP</a> explained to me what <a href="http://genomewiki.ucsc.edu/index.php/Bin_indexing_system">the bin indexing system</a> is yesterday. &nbsp;Here is what's originally explained in <a href="http://genome.cshlp.org/content/12/6/996.full.pdf">Jim Kent's paper</a>.&nbsp;</div><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-6k8AcqelBOM/UZt7y1RAEBI/AAAAAAAAAc4/778Qzl0EVnM/s1600/F7.medium.gif" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-6k8AcqelBOM/UZt7y1RAEBI/AAAAAAAAAc4/778Qzl0EVnM/s1600/F7.medium.gif" /></a></div><br /><span class="fig-label" style="border: 0px; color: #403838; font-family: 'Lucida Sans Unicode', Arial, 'Lucida Grande', Tahoma, Verdana, Helvetica, sans-serif; font-size: 12.499999046325684px; font-weight: bold; line-height: 11.11111068725586px; margin: 0px; outline-style: none; padding: 0px; vertical-align: baseline;">Figure 7.</span><span style="background-color: #eeeeee; color: #403838; font-family: 'Lucida Sans Unicode', Arial, 'Lucida Grande', Tahoma, Verdana, Helvetica, sans-serif; font-size: 12.499999046325684px; line-height: 11.11111068725586px;"></span><br /><div id="p-45" style="border: 0px; color: #403838; font-family: 'Lucida Sans Unicode', Arial, 'Lucida Grande', Tahoma, Verdana, Helvetica, sans-serif; font-size: 12.499999046325684px; line-height: 1.5; margin-bottom: 15px; margin-top: 15px; outline-style: none; padding: 0px; vertical-align: baseline;">Binning scheme for optimizing database accesses for genomic annotations that cover a particular region of the genome. This diagram shows bins of three different sizes. Features are put in the smallest bin in which they fit. A feature covering the range indicated by line&nbsp;<em style="border: 0px; font-family: inherit; font-size: inherit; line-height: inherit; margin: 0px; outline-style: none; padding: 0px; text-align: inherit; vertical-align: baseline;">A</em>would go in bin 1. Similarly, line&nbsp;<em style="border: 0px; font-family: inherit; font-size: inherit; line-height: inherit; margin: 0px; outline-style: none; padding: 0px; text-align: inherit; vertical-align: baseline;">B</em>&nbsp;goes in bin 4 and line<em style="border: 0px; font-family: inherit; font-size: inherit; line-height: inherit; margin: 0px; outline-style: none; padding: 0px; text-align: inherit; vertical-align: baseline;">C</em>&nbsp;in bin 20. When the browser needs to access features in a region, it must look in bins of all different sizes. To access all the features that overlapped or were enclosed by line&nbsp;<em style="border: 0px; font-family: inherit; font-size: inherit; line-height: inherit; margin: 0px; outline-style: none; padding: 0px; text-align: inherit; vertical-align: baseline;">A,</em>&nbsp;the browser looks in bins 1, 2, 3, 7, 8, 9, 10, and 11. For&nbsp;<em style="border: 0px; font-family: inherit; font-size: inherit; line-height: inherit; margin: 0px; outline-style: none; padding: 0px; text-align: inherit; vertical-align: baseline;">B</em>&nbsp;the browser looks in bins 1, 4, 14, 15, 16, 17. For&nbsp;<em style="border: 0px; font-family: inherit; font-size: inherit; line-height: inherit; margin: 0px; outline-style: none; padding: 0px; text-align: inherit; vertical-align: baseline;">C,</em>&nbsp;the browser looks in bins 1, 5, and 20.</div>For example, to select features (e.g. ESTs) overlapping with region of chr2:10000-20000, the query would be:<br /><br /><span style="font-family: Courier New, Courier, monospace;"> select * from chr2_est where chromStart &lt;20000 and chromEnd &gt;10000 and <span style="color: red;">(bin = 1 or bin = 2 or bin = 10 or bin = 74 or bin = 586)</span></span><br /><br />The additional bin=xxx part is to limit the searching only on the bins which can be only possible overlapped with the queried region. It can enhance the performance.<br /><br />This is query part. For encoding, each range supposed to have a bin number, which is the smallest bin (in order to save time for searching?) that it can fit. How to find the smallest bin?<br /><br />Here is C code in&nbsp;kent/src/lib/binRange.c to explain how to find the smallest bin that the range will fit in:<br /><br /><br /><span style="font-family: Courier New, Courier, monospace;">static int binFromRangeStandard(int start, int end)</span><br /><span style="font-family: Courier New, Courier, monospace;">/* Given start,end in chromosome coordinates assign it</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp;* a bin. &nbsp; There's a bin for each 128k segment, for each</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp;* 1M segment, for each 8M segment, for each 64M segment,</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp;* and for each chromosome (which is assumed to be less than</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp;* 512M.) &nbsp;A range goes into the smallest bin it will fit in. */</span><br /><span style="font-family: Courier New, Courier, monospace;">{</span><br /><span style="font-family: Courier New, Courier, monospace;">int startBin = start, endBin = end-1, i;</span><br /><span style="font-family: Courier New, Courier, monospace;">startBin &gt;&gt;=&nbsp;_binFirstShift;</span><br /><span style="font-family: Courier New, Courier, monospace;">endBin &gt;&gt;=&nbsp;_binFirstShift;</span><br /><span style="font-family: Courier New, Courier, monospace;">for (i=0; i&lt;ArraySize(binOffsets); ++i)</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; {</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; if (startBin == endBin)</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; return binOffsets[i] + startBin;</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; startBin &gt;&gt;=&nbsp;_binNextShift;</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; endBin &gt;&gt;=&nbsp;_binNextShift;</span><br /><span style="font-family: Courier New, Courier, monospace;">&nbsp; &nbsp; }</span><br /><span style="font-family: Courier New, Courier, monospace;">errAbort("start %d, end %d out of range in findBin (max is 512M)", start, end);</span><br /><span style="font-family: Courier New, Courier, monospace;">return 0;</span><br /><span style="font-family: Courier New, Courier, monospace;">}</span><br /><br />where _binNextShift=3, _binFirstShift=17, and binOffsets[] = {512+64+8+1, 64+8+1, 8+1, 1, 0}.<br /><br />You can understand binOffsets as the 0-based index of the first rooms of every floor, but in descending order. By adding the offset, you will get the global index of the bin in the whole structure.