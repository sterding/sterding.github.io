---
layout: post
title: AWK learning note
date: '2008-09-10T05:17:00.000-04:00'
author: Xianjun
tags: 
modified_time: '2008-09-10T05:18:55.660-04:00'
blogger_id: tag:blogger.com,1999:blog-12445049.post-3899265028627730123
blogger_orig_url: http://onetipperday.blogspot.com/2008/09/awk-learning-note.html
---

<b> 1.  first update the internal variables when reading one line:</b><br /><ol><li> 當 AWK 從資料檔中讀取一筆資料列時, AWK 會使用內建變數$0 予以記錄.</li><li> AWK 會立刻重新分析 $0 的欄位情況, 並將 $0 上各欄位的資料用 $1, $2, ..予以記錄.</li></ol><pre><br />例如 : AWK 從資料檔 emp.dat 中讀入第一筆資料列<br />"A125 Jenny 100 210" 之後, 程式中:<br />$0 之值將是 "A125 Jenny 100 210"<br />$1 之值為 "A125" $2 之值為 "Jenny"<br />$3 之值為 100 $4 之值為 210<br />NF 之值為 4 $NF 之值為 210<br />NR 之值為 1 FILENAME 之值為 ``emp.dat''<br /><pre>where NF: Number of Fields in current $0<br />NR: Number of Records of currently having been read.<br />FILENAMEAWK: filename of current proceeding<br /><br />2. <b><b>'PATTERN{ACTION}' or -f script.awk<br /></b></b>the following two ways are same<b><b>:<br /><br /></b></b><span style="font-family: verdana,sans-serif;">$awk -f pay1.awk emp.dat</span><br /><span style="font-family: verdana,sans-serif;">$awk ' { print $2, $3 * $4 } ' emp.dat</span><br /><br />if you save the script into a file named pay1.awk.<br />讀者可使用``-f''參數,讓AWK主程式使用其它僅含 AWK函數 的<br />檔案中的函數<br />其語法如下:<br />awk -f AWK主程式檔名 -f AWK函數檔名 資料檔檔名<b><b><br /></b></b></pre></pre><pre><pre><b>3. BEGIN/END and array in AWK</b><br />for example, we have a data file like:<br /></pre></pre> Mary O.S. Arch. Discrete<br />Steve D.S. Algorithm Arch.<br />Wang Discrete Graphics O.S.<br />Lisa Graphics A.I. Lily Discrete Algorithm <pre><pre>---------------------------------------<br /></pre></pre><span style="font-family: courier new,monospace;">{for( i=2; i<><br /><span style="font-family: courier new,monospace;">END{<br /><span>    </span>for(coursein Number)<br /><span>    </span><span>    </span>printf("\%-10s %d\n", course, Number[course] )<br />}</span><br /><pre><pre>---------------------------------------<br /></pre></pre>comment:<br />a. NF=4 in this case, line number<br />b. END is a AWK之保留字, 為{ Pattern}之一種, like BEGIN. The only difference is END only run after all lines are proceeded, while BEGIN works initially before the script, and only one time (both BEGIN and END).<br />c. $i represents the ith elements in the line array, which is different from Perl program (in which, the $i is a variable name, in AWK, variable name cannot begin with $.)<br /><br /><b>4. Shell command and awk command</b><br />for example:<br /><pre><pre>---------------------------------------<br /></pre></pre> <span style="font-family: courier new,monospace;">BEGIN { </span><br /><span style="font-family: courier new,monospace;"> while ( "who" | getline ) n++ </span><br /><span style="font-family: courier new,monospace;"> print n </span><br /><span style="font-family: courier new,monospace;"> }</span><br /><pre><pre>---------------------------------------<br />where the who is a system command used in shell, and the getline is an awk command for input;<br /></pre></pre><br /><b>5. Filename in the script should be quoted by "", </b><br />for example,<br /><pre><pre>---------------------------------------<br /></pre></pre><span style="font-family: courier new,monospace;">BEGIN { </span><br /><span style="font-family: courier new,monospace;">    print `` ID Number Arrival Time'' > ``today_rpt1''</span><br /><span style="font-family: courier new,monospace;">    print ``==========================='' > ``today_rpt1''</span><br /><span style="font-family: courier new,monospace;"> } </span><br /><br /><span style="font-family: courier new,monospace;"> { printf(" %s %s\n", $1,$2 ) > "today_rpt1" } </span><br /><pre><pre>---------------------------------------<br /></pre></pre> $awk -f reformat1.awk arr.dat<br /><br />Note:<br /><b>a. </b>if today_rpt1 is not quoted by "", then it will be taken as a variable (which default value is 0, or Null String in AWK.)<br /><b>b.</b> the redirection mark is '>', not '>>‘, even you want to append to the end of the file. The only difference between them is, for '>>', it will append to the end of the file if it's open first time and the file exists. For '>', AWK will create a new file when it occurs first time, then append to the end (like '>>'). This is little bit different from Unix.<br /><br /><b>6. Input and output command in Awk</b><br />AWK input command: getline<br />AWK output command: print, printf<br /><br /><b>7. three ways to run awk</b><br />a. <span style="font-family: courier new,monospace;">$awk '{print}' file1.txt file2.txt</span><br />b. <span style="font-family: courier new,monospace;">$awk -f myscript.awk file1.txt file2.txt</span><br />save <u><i>{print}</i></u> into a file(myscript.awk) first<br />c. <span style="font-family: courier new,monospace;">$myshell file1.txt file2.txt</span><br />save <u><i>awk '{print}' $*</i> </u>into a shell file(named myshell. Here $* means all parameters after the shell command. You also can use $1 represents the first parameter, and $2 the second one.<br /><br /><b>8. FS(Field Separator) and RS(Record Separator)</b><br />By default, the FS is any empty character (space, \t, ), RS is newline '\n'. But they can be changed, like<br /><br /><pre><pre>--------------------------------------- make_report.awk -------------------------<br /></pre></pre><span style="font-family: courier new,monospace;">BEGIN {</span><br /><span style="font-family: courier new,monospace;">        FS = "\n"</span><br /><span style="font-family: courier new,monospace;">        RS = ""</span><br /><span style="font-family: courier new,monospace;">        split( "一. 二. 三. 四. 五. 六. 七. 八. 九.", C_Number, " " )</span><br /><span style="font-family: courier new,monospace;">    }</span><br /><span style="font-family: courier new,monospace;">    {</span><br /><span style="font-family: courier new,monospace;">        printf("\n%s 報告人 : %s \n",C_Number[NR],$1)</span><br /><span style="font-family: courier new,monospace;">        for( i=2; i<= NF; i++)</span><br /><span style="font-family: courier new,monospace;">        printf(" %d. %s\n", i-1, $i)</span><br /><span style="font-family: courier new,monospace;">    }</span><br /><pre><pre>--------------------------------------- week.rpt ------------------------------<br /><br />張長弓<br /><br />GNUPLOT 入門<br /><br /><br /><br />吳國強<br /><br />Latex 簡介<br /><br />VAST-2 使用手冊<br /><br />mathematica 入門<br /><br /><br /><br /><br /><br /><br /><br /><br /><br />李小華<br /><br />AWK Tutorial Guide Regular Expression<b><br /></b><pre>--------------------------------------- Output ------------------------</pre>[xianjund@douglasgran data]$ awk -f make_report week.rpt<br /><br />一. 報告人 : 張長弓<br />1. GNUPLOT    入門<br /><br />二. 報告人 : 吳國強<br />1. Latex 簡介<br />2. VAST-2 使用手冊<br />3. mathematica 入門<br /><br />三. 報告人 : 李小華<br />1. AWK Tutorial Guide Regular Expression<br /><pre><pre>---------------------------------------<br /></pre></pre><span style="font-size:180%;"><span style="font-weight: bold; font-family: times new roman;">9. ARGC and ARGV[]<br /><br /></span></span>like C, but<br />a. ARGC does not include the -v, -f and their options. for example, in <br />$awk -vx=36 -f program1 data1 data2<br />or<br />$awk '{ print $1 ,$2 }' data1 data2<br /></pre></pre>ARGC=3<br />ARGV[0]= "awk"<br />ARGV[1]="data1"<br />ARGV[2]="data2"